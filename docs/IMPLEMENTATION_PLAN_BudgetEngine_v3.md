<!--
FILE: docs/IMPLEMENTATION_PLAN_BudgetEngine_v3.md
SCOPO: Piano di implementazione per il Budget Engine v3 (LIVE/APP/Addendum/Planned Items) basato su decisioni e Q&A ufficiali.
INPUT: docs/mpit_budget_engine_v3_decisions (3).md, docs/questions-mpit_budget_engine_v3_decisions.md, stato attuale codice/app.
OUTPUT/SIDE EFFECTS: Documento di piano testuale; nessuna modifica applicativa, guida per le prossime modifiche.
-->

# Implementation Plan — MPIT Budget Engine v3

## 1) Requisiti estratti (con fonte)
- Eliminare Baseline/Forecast a favore di Live (rolling) + Snapshot Approved (APP) creato solo via azione dedicata; Approved ammesso solo su APP; naming `{prefix}{year}-LIVE-{NN}` / `{prefix}{year}-APP-{NN}` con migrazione/rename degli esistenti `BUD-` (docs/mpit_budget_engine_v3_decisions (3).md §4.1, §5.1–5.3; docs/questions-mpit_budget_engine_v3_decisions.md §9.1, §9.7).
- Budget Live auto-refresh su eventi di sorgenti validate per anno corrente+1, pulsante “Forza refresh” resta; se manca LIVE per anno in orizzonte va auto-creato e aggiornato (docs/mpit_budget_engine_v3_decisions (3).md §4.2, §9.1–9.2; docs/questions-mpit_budget_engine_v3_decisions.md §9.5).
- Stati sorgente: contratti inclusi solo se Active/Pending Renewal/Renewed; esclusi Draft/Cancelled/Expired; Draft non triggera refresh e non va normalizzato a Active. Progetti inclusi Approved/In Progress/On Hold, Completed solo se con Planned Items non coperti o spend_date rilevante; Draft/Proposed/Cancelled esclusi. Transizioni verso/da stati validati triggerano refresh; regressione a Draft/Proposed cancella righe generate (docs/mpit_budget_engine_v3_decisions (3).md §7.1–7.3; docs/questions-mpit_budget_engine_v3_decisions.md §9.4).
- Rigenerazione idempotente: righe generate obsolete devono essere cancellate (non `is_active=0`); righe generate devono restare rigenerabili e il Live non è editabile manualmente (docs/mpit_budget_engine_v3_decisions (3).md §4.4, §5.1, §11).
- Contratti modellati solo con tabella Termini (`from_date`, `to_date` opzionale, `amount_net`, `billing_cycle`); niente spread_months/rate_schedule/custom logic; auto-renew limitato a orizzonte anno corrente+1 (docs/mpit_budget_engine_v3_decisions (3).md §4.5, §4.8, §12).
- Progetti alimentano il budget tramite `MPIT Planned Item` standalone (non child table): campi project/description/amount/spend_date/distribution(all|start|end default all)/flag coverage; lifecycle Draft→Submit; quotes servono solo per prefill Planned Items, non per il calcolo diretto (docs/mpit_budget_engine_v3_decisions (3).md §4.6, §6.2.4, §8; docs/questions-mpit_budget_engine_v3_decisions.md §9.8, §10.2).
- Planned Item coperto da Contract o Actual: `is_covered=1` + dynamic link (`covered_by_type/name`) e l’item è escluso dal calcolo (nessuna riga a zero); spend_date richiesta e non nel passato, valida solo per anno corrente o successivo (docs/questions-mpit_budget_engine_v3_decisions.md §9.3, §10.2).
- Distribuzione multi-anno: precedenza a spend_date (mese/anno della data); se assente o periodo multi-anno, modalità `all` (uniforme sui mesi overlap con rounding sull’ultimo), `start` (tutto al primo mese), `end` (tutto all’ultimo); nessuna modalità proportional (docs/mpit_budget_engine_v3_decisions (3).md §8.2–8.3; docs/questions-mpit_budget_engine_v3_decisions.md §10.3).
- Anno chiuso: dopo `MPIT Year.end_date` auto-refresh OFF; manual refresh consentito con warning/dialogo esplicito e log in timeline; Live comunque non editabile; Addendum ancora permessi (docs/mpit_budget_engine_v3_decisions (3).md §4.9, §9.3; docs/questions-mpit_budget_engine_v3_decisions.md §9.6).
- Addendum: nuovo DocType `MPIT Budget Addendum` submittable (docstatus 0/1); campi year, cost_center, delta_amount (±), reason (req), reference_snapshot (Link MPIT Budget filtrato su budget_type=Snapshot + anno + cost_center); autoname `ADD-{year}-{cost_center_abbr}-{####}`; submit bloccato se non esiste Snapshot approvato per stesso year+cost_center; cap per cost center = Snapshot(APP) + somma Addendum approvati (docs/mpit_budget_engine_v3_decisions (3).md §10.2; docs/questions-mpit_budget_engine_v3_decisions.md §10.1).
- Rolling horizon: refresh/generazione limitati ad anno corrente + 1; items fuori orizzonte marcati `out_of_horizon=1` senza creare budget, da rivalutare quando rientrano (docs/mpit_budget_engine_v3_decisions (3).md §2.3, §9.1; docs/questions-mpit_budget_engine_v3_decisions.md “Additional reviewer notes”).
- Reporting/UI: rimuovere report legacy Baseline/Forecast/is_active e sostituire con minimi v3 (Plan vs Cap vs Actual per cost center, Monthly plan che rispetta spend_date/distribuzione, Renewals su Termini); workspace/dashboard/chart va allineata per evitare link rotti (docs/questions-mpit_budget_engine_v3_decisions.md “Report legacy: decisione finale”).
- Invarianti dati: Cost Center obbligatorio su tutto ciò che impatta limiti/actual; righe generate cancellabili/rigenerabili; nessun doppio conteggio tra Planned Items/Contratti/Actual; Budget Live non editabile (docs/mpit_budget_engine_v3_decisions (3).md §11, §5.1).
- Cost Center abbr: aggiungere campo `abbr` su MPIT Cost Center; autopopolarlo in validate con slug stabile se assente; usare `abbr` per autoname Addendum `ADD-{year}-{abbr}-{####}` (decisione utente 1).
- Planned Item periodo/distribuzione: aggiungere campi `start_date` (reqd), `end_date` (reqd), `spend_date` (opzionale), `distribution` (all/start/end, default all). Precedenza: spend_date valorizzata → importo nel mese/anno della data ignorando distribution; spend_date vuota → overlap mesi tra start/end e anno budget con distribution (all uniforme, start 100% primo mese, end 100% ultimo mese); nessuna proportional (decisione utente 2).
- Copertura Planned Item: usare `is_covered`, `covered_by_type`, `covered_by_name` (Dynamic Link) con set/reset in validate/on_update; timeline comment “Covered by {type} {name}” / “Uncovered (cleared covered_by)”; item coperto escluso dal calcolo budget (decisione utente 3).
- Dimensione cost center Snapshot/Addendum: Budget resta annuale senza cost_center header; Addendum year+cost_center valido solo se reference_snapshot è APP Approved per anno e contiene almeno una riga Allowance per quel CC; cap CC = Allowance Snapshot + Addendum approvati (decisione utente 4).
- Auto-refresh/eventi: trigger su Contract (stato valido e cambi impattanti), Planned Item (submit/cancel/modifiche chiave), Project se resta sorgente, Addendum (submit/cancel). Draft Addendum non triggera. Skip per anno chiuso o fuori orizzonte con comment timeline “skipped”; comment timeline per refresh; errori via frappe.log_error(); dedup per year/CC se possibile (decisione utente 5).

## 2) Mappa del codice attuale
- DocTypes esistenti: `MPIT Budget` (Baseline/Forecast, fields/naming_series `BUD-.YYYY.-`, buttons refresh/set_active; controller `mpit_budget.py` con logica refresh da Contracts/Projects, usa `is_active` su righe generate), `MPIT Budget Line` (line_kind Contract/Project/Allowance/Manual con flag `is_generated`/`is_active`), `MPIT Contract` (spread_months/rate_schedule, status normalization Draft→Active, auto_renew senza orizzonte), `MPIT Project` (allocations/quotes/deltas), `MPIT Actual Entry`, `MPIT Year`, `MPIT User Preferences`, `MPIT Settings`, child tables per rate/alloc/quote/milestone, reports sotto `master_plan_it/master_plan_it/report/*` basati su Baseline/Forecast e `is_active`, chart source `dashboard_chart_source/mpit_plan_delta_by_cost_center`.
- DocTypes mancanti rispetto ai requisiti: `MPIT Budget Addendum`, `MPIT Planned Item` standalone; nessun campo budget_type/naming LIVE/APP; nessun flag year_close o horizon sugli oggetti esistenti.
- Logiche di calcolo/validazione: `mpit_budget.py` gestisce naming BUD-{year}, refresh, distribuzione uniforme, deattiva righe generate; `mpit_contract.py` applica spread/rate, normalizza status su auto_renew; `mpit_project.py` calcola totals da allocations/quotes/Actual Entry Delta; `annualization.py` fornisce overlap_months ma solo per Monthly/Quarterly/Annual; `mpit_budget.js` gestisce pulsanti refresh/set_active.
- UI/Workspace: workspace `master_plan_it/workspace/master_plan_it/master_plan_it.json` punta a report legacy e quick actions “Create Forecast Budget/Refresh Active Forecast/Record Allowance Spend”; nessun riferimento a Addendum o Planned Items.
- Install/bootstrap: `setup/install.py` crea settings, anni corrente+next, ricarica workspace/dashboard; `hooks.py` non ha scheduler/trigger; nessuna auto-refresh job.
- File da toccare (prima stima): controller/JSON di Budget, Budget Line, Contract, Project, Actual Entry, Settings/User Prefs (naming), annualization utilities, nuova folder doctype per Addendum e Planned Item (controller + JSON + JS se necessario), hooks/install per scheduler e auto-create budgets, workspace/dashboard/report/cartelle report, eventuale chart source cleanup.

## 3) Decisioni integrate (follow-up)
- Aggiungere `abbr` su MPIT Cost Center con autopopolamento in validate se vuoto; usare `abbr` per autoname Addendum `ADD-{year}-{abbr}-{####}`.
- Planned Item standalone con `start_date`, `end_date` obbligatori, `spend_date` opzionale, `distribution` all/start/end; precedenza spend_date vs distribuzione come sopra.
- Copertura Planned Item tramite covered_by_type/name (Dynamic Link) con set/reset is_covered e timeline comment sul cambiamento; item coperto escluso dal calcolo.
- Budget annuale senza cost_center header; Addendum year+cost_center validato su Snapshot APP approvato con riga Allowance per CC; cap CC = Allowance Snapshot + Addendum approvati.
- Auto-refresh su eventi Contract/Planned Item/Project se usato/Addendum (submit/cancel); skip per anno chiuso o fuori orizzonte con comment “skipped”; errori via log_error; dedup year/CC se possibile; comment timeline per refresh.

## 4) Strategia di verifica (post-implementazione)
- Rieseguire confronto requisiti vs implementazione rileggendo docs v3 + Q&A (checklist requisito per requisito).
- Migrazioni: verificare rename Budget (LIVE/APP) e creazione Addendum/Planned Item con `bench --site <site> migrate` e controlli DB (esistenza docfields, naming_series).
- Funzionale: creare/aggiornare contratti (Draft→Active, auto_renew) e Planned Items con spend_date nell’orizzonte e fuori orizzonte per verificare refresh corrente+1, cancellazione righe obsolete, copertura Planned Item quando si collega un Contract/Actual, comportamento anno chiuso (banner + log timeline).
- Snapshot/Addendum: creare Snapshot APP da LIVE, tentare submit Addendum senza Snapshot (errore atteso), poi con Snapshot valido e verificare calcolo cap (Snapshot + Addendum approvati) e naming.
- UI/Workspace: verificare che workspace aggiornata non contenga link a report legacy e includa scorciatoie per Live/Snapshot/Addendum/Planned Items, che Budget Live resti non editabile e che warning anno chiuso appaia su refresh manuale.
- Reporting: controllare che report/chart legacy rimossi o aggiornati non causino errori di import e che nuovi report rispettino spend_date/distribuzione e cap per cost center.
